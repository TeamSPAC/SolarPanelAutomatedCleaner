/*
 * ======================================================================================
 * 
 * Solar Panel Automated Cleaner
 * Written by: Aaron Hale
 * 2018 Senior Design
 * Mississippi State University
 * Team: Dylan Nolan, Daniel Coats, Scott Watson, Aaron Hale
 * 
 * ======================================================================================
*/

/*
 * #include includes the necessary libraries for the arduino to implement different 
 * components of SPAC
 */
#include <Wire.h>
#include <Adafruit_MotorShield.h>
#include "utility/Adafruit_MS_PWMServoDriver.h"
#include "hcsr04.h"
#include "WiFiEsp.h"
#include "HX711.h"
#include "SoftwareSerial.h"
#include <Adafruit_Sensor.h>
#include <Adafruit_LSM303_U.h>
#include "utility/Adafruit_MS_PWMServoDriver.h"
#include <Servo.h>

/*
 * #define allows us to define what pin values are associated to the trig and echo 
 * pins of the ultrasonic sensors.
 * 
 *            -----------------------
 *LeftFront-> |                      | <-RightFront
 *            |                      |
 *            |                      |
 *            |                      |
 *            |                      |
 *            |                      |
 *LeftRear->  |                      | <-RightRear
 *            -----------------------
 *              ^                 ^
 *              |                 |
 *           RearLeft         RearRight
 */
 
#define TRIG_PIN_LeftRear 22
#define ECHO_PIN_LeftRear 23
#define TRIG_PIN_RightRear 26
#define ECHO_PIN_RightRear 27
#define TRIG_PIN_RearRight 25
#define ECHO_PIN_RearRight 24
#define TRIG_PIN_RearLeft 28
#define ECHO_PIN_RearLeft 29
#define NUM_SAMPLES 10
#define calibration_factor -7050.0
#define DOUT  3
#define CLK  2

/*
 * Using the HCSR04 library we can use the defined pin values to set up the ultrasonics 
 * for use in the code.
 */
 
HCSR04 hcsr04LeftRear = HCSR04(ECHO_PIN_LeftRear,TRIG_PIN_LeftRear);
HCSR04 hcsr04RightRear = HCSR04(ECHO_PIN_RightRear,TRIG_PIN_RightRear);
HCSR04 hcsr04RearRight = HCSR04(ECHO_PIN_RearRight,TRIG_PIN_RearRight);
HCSR04 hcsr04RearLeft = HCSR04(ECHO_PIN_RearLeft,TRIG_PIN_RearLeft);

/*
 * Next using the motorshield library we can set up the motorshield for use. We can now
 * name each of the motors for use throughout the code.
 */

Adafruit_MotorShield AFMS = Adafruit_MotorShield(0x61); 

Adafruit_DCMotor *MotorLeft1 = AFMS.getMotor(1);
Adafruit_DCMotor *MotorRight1 = AFMS.getMotor(2);
Adafruit_DCMotor *MotorLeft2 = AFMS.getMotor(3);
Adafruit_DCMotor *MotorRight2 = AFMS.getMotor(4);

/*
 * Now we need to define some variables for the code. Each one needs to be given a type and a name. 
 * The first few are used for helping with distance knowledge.
 */


Servo myservo;  // create servo object to control a servo


unsigned long starttime;
unsigned long endtime;
unsigned long accumtime;
unsigned long timeddistance;
unsigned long accumdistance;
int starttimer;

/*
 * The following letters are used for ultrasonic values.
 * a - leftrear
 * b - leftfront
 * c - rightrear
 * d - rightfront
 * e - rearright
 * f - rearleft
 */
 
long a;
long b;
long c;
long d;
long e;
long f;

/*
 * Counter were used before timing. We left them just in case we want to go back to using it.
 */
 
int counterlength;
int counterwidth;
float distance;

/*
 * Next we have a few to keep up with what the robot has done so that we can skip sections if 
 * it has already done them.
 * turns - how many turns it has taken
 * forward - moving forward
 * last - uses left and right values as knowledge as to what turn the robot made last
 * forwardleft - the robot started at the bottom left of the panel
 * forward right - the robot started at the bottom right of the panel
 * almost - almost done
 * done - done cleaning
 * turnaround - done cleaning and needs to turn around because it stopped on he wrong side of the panel from where it started
 */
 
int turns;
int forward;
int last;
int right;
int left;
int forwardleft;
int forwardright;
int almost;
int done;
int turnaround;

/*
 * The next ones are for the voltage sensor calculations to give voltage
 * 
 */
char ssid[] = "SPAC";
char pass[] = "12345678";

int signalstrength = 0;
int sum = 0;                    // sum of samples taken
unsigned char sample_count = 0; // current sample number
float tempvoltage = 0.0;            // calculated voltage
float voltage = 0.0;

float solutionpounds;
int solutionpercent;
int voltagepercent;
int signalpercent;
float step1;
float step2;
float step3;

int status = WL_IDLE_STATUS;

int greenledStatus = LOW;
int redledStatus = LOW;
int pump = 34;
int reqCount = 0;

int greaterthan90 = 0;
int lessthan90 = 0;

int squeegeeturnright = 0;
int squeegeeturnleft = 0;

/* Assign a unique ID to this sensor at the same time */
Adafruit_LSM303_Mag_Unified mag = Adafruit_LSM303_Mag_Unified(12345);
float oldheading = 0;
float newheading = 0;
float heading = 0;
int compassstart = 0;
int compassstop = 0;
int compassturntime = 0;
    
HX711 scale(DOUT, CLK);

#ifndef HAVE_HWSERIAL1
#include "SoftwareSerial.h"
SoftwareSerial Serial1(18, 19); // RX, TX
#endif


WiFiEspServer server(80);

// use a ring buffer to increase speed and reduce memory allocation
RingBuffer buf(8);

/*
 * void setup allows us to setup different values and pins based on naming.
 */
 
void setup() {
   /*
   * begin serial communication baud rate set to 9600
   */
   
  Serial.begin(9600);

  /*
   * Wifi section
   */

  pinMode(pump, OUTPUT);
  
  pinMode(7, OUTPUT); // initialize digital pin LED_BUILTIN as an output.
  Serial1.begin(9600);    // initialize serial for ESP module
  WiFi.init(&Serial1);    // initialize ESP module

  // check for the presence of the shield
  if (WiFi.status() == WL_NO_SHIELD) {
    Serial.println("WiFi shield not present");
    // don't continue
    while (true);
  }

  Serial.print("Attempting to start AP ");
  Serial.println(ssid);

  status = WiFi.beginAP(ssid, 10, pass, ENC_TYPE_WPA2_PSK);

  Serial.println("Access point started");
  
  printWifiStatus();
  
  // start the web server on port 80
  server.begin();

  scale.set_scale(calibration_factor); //This value is obtained by using the SparkFun_HX711_Calibration sketch
  scale.tare(); //Assuming there is no weight on the scale at start up, reset the scale to 0

   /*
    * Next section
    */
    
  turnaround = 0;
  almost = 0;
  done = 0;
  counterlength = 0;
  counterwidth = 0;
  turns = 0;
  forward = 0;
  last = 0;
  right = 1; //lets make right = 1
  left = 2; //lets make left = 2
  pinMode(30,INPUT); //pin 30 (IR Sensor) is an input value of 0 or 1
  pinMode(33,INPUT); //pin 33(IR Sensor) is an input value of 0 or 1  
  pinMode(36,INPUT); //pin 30 (IR Sensor) is an input value of 0 or 1
  pinMode(37,INPUT); //pin 33(IR Sensor) is an input value of 0 or 1

  /*
   * lets initialize the motors
   */
   
  AFMS.begin(); // start the motors
  MotorLeft1->setSpeed(150); //left rear speed set
  MotorRight1->setSpeed(147); //right speed set
  MotorLeft2->setSpeed(150); //left front speed set
  MotorRight2->setSpeed(147); //right speed set



  /*
   * delay 1 second after setup
   */
   
  //delay(1000);

  /*
   * starttime is set to millis() which is an arduino library using milliseconds
   */
   
  

  if(!mag.begin())
      {
        /* There was a problem detecting the LSM303 ... check your connections */
        Serial.println("Ooops, no LSM303 detected ... Check your wiring!");
        while(1);
      }
    }


/*
 * This loop is what runs the entire robot. This allows us continuously read inputs and 
 * look at if statements based on the values. These if statements in turn do more steps
 * of what the robot should do then move on to do the next thing.
 */
 
void loop() {
  /*
   * lets do the wifi first
   */
   
  while (sample_count < NUM_SAMPLES) {
        sum += analogRead(A1);
        sample_count++;
        delay(10);
    }

    tempvoltage = ((float)sum / (float)NUM_SAMPLES * 5.015) / 1024.0;

    
  WiFiEspClient client = server.available();  // listen for incoming clients

  if (client) {                               // if you get a client,
    Serial.println("New client");             // print a message out the serial port
    buf.init();                               // initialize the circular buffer
    while (client.connected()) {              // loop while the client's connected
      if (client.available()) {               // if there's bytes to read from the client,
        char c = client.read();               // read a byte, then
        buf.push(c);                          // push it to the ring buffer

        // printing the stream to the serial monitor will slow down
        // the receiving of data from the ESP filling the serial buffer
        //Serial.write(c);
        
        // you got two newline characters in a row
        // that's the end of the HTTP request, so send a response
        
        if (buf.endsWith("\r\n\r\n")) {
          sendHttpResponse(client);
          break;
        }

        // Check to see if the client request was "GET /H" or "GET /L":
        if (buf.endsWith("GET /GH")) {
          Serial.println("Turn green led ON");
          greenledStatus = HIGH;
          digitalWrite(7, HIGH);   // turn the LED on (HIGH is the voltage level)
        }
        /*else if (buf.endsWith("GET /GL")) {
          Serial.println("Turn green led OFF");
          greenledStatus = LOW;
          digitalWrite(7, LOW);    // turn the LED off by making the voltage LOW
        }*/
      }
    }
    Serial.println("Here");
    // close the connection
    client.stop();
    Serial.println("Client disconnected");
  }
  
/*
 * The next read all of the ultrasonic sensors and print them over the serial communication
 */
if(greenledStatus == 1){
  Serial.println(last);
  Serial.println(done);
  Serial.println(accumtime);
  Serial.println(accumdistance);
  a = hcsr04LeftRear.distanceInMillimeters();
  Serial.print(a);
  Serial.println("mmLeftRear");
  c = hcsr04RightRear.distanceInMillimeters();
  Serial.print(c);
  Serial.println("mmRightRear");
  e = hcsr04RearRight.distanceInMillimeters();
  Serial.print(e);
  Serial.println("mmRearRight");
  f = hcsr04RearLeft.distanceInMillimeters();
  Serial.print(f);
  Serial.println("mmRearLeft");

/*
 * the next read and print the IR Sensor Values
 */
  
  int irreadFront = digitalRead(33);
  Serial.print(irreadFront);
  Serial.println("IRFront");
  int irreadRear = digitalRead(30);
  Serial.print(irreadRear);
  Serial.println("IRRear");
  int irreadRight = digitalRead(36);
  Serial.print(irreadRight);
  Serial.println("IRRight");
  int irreadLeft = digitalRead(37);
  Serial.print(irreadLeft);
  Serial.println("IRLeft");

  digitalWrite(pump, HIGH);
  
  if (counterlength == 0) {
    starttime = millis(); //start the timer
  }
  
 /*
  * lets run forward with the right rear sensor reading off the edge
  */
  
  if (not done and counterwidth == 0 and ((not irreadRight and not irreadFront and not irreadRear) or (not irreadRight and irreadFront and not irreadRear))) {
    MotorLeft1->run(FORWARD);  
    MotorRight1->run(FORWARD);  
    MotorLeft2->run(FORWARD);
    MotorRight2->run(FORWARD);

    
    forwardright = 1;
    forwardleft = 0;
    counterlength = counterlength + 1;
    
    Serial.println("1"); //debugging tool to tell what if statement was entered
    return;
  }

  /*
   * else, we need to fix the orientation keeping the robot straight
   */
   /*else if ((irreadRight and not irreadFront and not irreadRear) or (irreadRight and irreadFront and not irreadRear)) {
    MotorLeft1->run(BACKWARD);  
    MotorRight1->run(FORWARD);  
    MotorLeft2->run(BACKWARD);
    MotorRight2->run(FORWARD);
    
    delay(50);
    
    Serial.println("TRY TO REDIRECT RIGHT");
    
    MotorLeft1->run(FORWARD);  
    MotorRight1->run(FORWARD);  
    MotorLeft2->run(FORWARD);
    MotorRight2->run(FORWARD);
    
    counterlength = counterlength + 1;
    
    delay(200); 
    return;
  }*/
  
  /*else if (not done and counterwidth == 0 and (forwardright and last == 0 and ((irreadLeft and not irreadFront and not irreadRear) or (irreadLeft and irreadFront and not irreadRear)))) {
    MotorLeft1->run(FORWARD);  
    MotorRight1->run(BACKWARD);  
    MotorLeft2->run(FORWARD);
    MotorRight2->run(BACKWARD);
    
    delay(50);
    
    Serial.println("TRY TO REDIRECT RIGHT");
    
    MotorLeft1->run(FORWARD);  
    MotorRight1->run(FORWARD);  
    MotorLeft2->run(FORWARD);
    MotorRight2->run(FORWARD);
    
    counterlength = counterlength + 1;
    
    delay(200); 
    return; 
  }*/
  
  else if (not done and counterwidth == 0 and (forwardright and last == 0 and ((irreadRight and not irreadFront and not irreadRear) or (irreadRight and irreadFront and not irreadRear)))) {
    MotorLeft1->run(BACKWARD);  
    MotorRight1->run(FORWARD);  
    MotorLeft2->run(BACKWARD);
    MotorRight2->run(FORWARD);
    
    delay(50);
    
    Serial.println("TRY TO REDIRECT LEFT");
    
    MotorLeft1->run(FORWARD);  
    MotorRight1->run(FORWARD);  
    MotorLeft2->run(FORWARD);
    MotorRight2->run(FORWARD);
    
    counterlength = counterlength + 1;
    
    delay(200); 
    return; 
  }

  /*
   * we need to do the same thing but for if the robot is set on the left side and the left rear sensor is reading off the edge
   */
   
 /* if (not done and counterwidth == 0 and ((a > 200 and b < 200 and not irreadFront and not irreadRear) or (a > 200 and b < 200 and irreadFront and not irreadRear))) {
    MotorLeft1->run(FORWARD);  
    MotorRight1->run(FORWARD);  
    MotorLeft2->run(FORWARD);
    MotorRight2->run(FORWARD);
    
    delay(100);
    
    forwardleft = 1;
    forwardright = 0;
    counterlength = counterlength + 1;
    
    Serial.println("2");
  }
  
  else if (not done and counterwidth == 0 and (forwardleft and last == 0 and ((a < 200 and not irreadFront and not irreadRear) or (a < 200 and irreadFront and not irreadRear)))) {
    MotorLeft1->run(BACKWARD);  
    MotorRight1->run(FORWARD);  
    MotorLeft2->run(BACKWARD);
    MotorRight2->run(FORWARD);
    
    delay(50);
    
    Serial.println("TRY TO REDIRECT LEFT");
    
    MotorLeft1->run(FORWARD);  
    MotorRight1->run(FORWARD);  
    MotorLeft2->run(FORWARD);
    MotorRight2->run(FORWARD);
    
    counterlength = counterlength + 1;
    
    delay(200);  
  }
  
  else if (not done and counterwidth == 0 and (forwardleft and last == 0 and ((b > 200 and not irreadFront and not irreadRear) or (b > 200 and irreadFront and not irreadRear)))) {
    MotorLeft1->run(FORWARD);  
    MotorRight1->run(BACKWARD);  
    MotorLeft2->run(FORWARD);
    MotorRight2->run(BACKWARD);
    
    delay(50);
    
    Serial.println("TRY TO REDIRECT LEFT");
    
    MotorLeft1->run(FORWARD);  
    MotorRight1->run(FORWARD);  
    MotorLeft2->run(FORWARD);
    MotorRight2->run(FORWARD);
    
    counterlength = counterlength + 1;
    
    delay(200);  
  }*/

  //now for width
  if (not done and turns == 1 and counterlength > 0 and ((not irreadRight and not irreadFront and not irreadRear) or (not irreadRight and irreadFront and not irreadRear))) {
    MotorLeft1->run(FORWARD);  
    MotorRight1->run(FORWARD);  
    MotorLeft2->run(FORWARD);
    MotorRight2->run(FORWARD);

    digitalWrite(pump, HIGH);
    
    delay(100);
    
    forwardright = 1;
    forwardleft = 0;
    counterwidth = counterwidth + 1;
    
    Serial.println("2");
  }
  
  /*else if (not done and turns == 1 and counterlength > 0 and (forwardright and last == 0 and ((irreadLeft and not irreadFront and not irreadRear) or (irreadLeft and irreadFront and not irreadRear)))) {
    MotorLeft1->run(FORWARD);  
    MotorRight1->run(BACKWARD);  
    MotorLeft2->run(FORWARD);
    MotorRight2->run(BACKWARD);
    
    delay(50);
    
    Serial.println("TRY TO REDIRECT LEFT");
    
    MotorLeft1->run(FORWARD);  
    MotorRight1->run(FORWARD);  
    MotorLeft2->run(FORWARD);
    MotorRight2->run(FORWARD);
    
    counterwidth = counterwidth + 1;
    
    delay(200);  
  }*/

  /*else if ((irreadRight and not irreadFront and not irreadRear) or (irreadRight and irreadFront and not irreadRear)) {
    MotorLeft1->run(BACKWARD);  
    MotorRight1->run(FORWARD);  
    MotorLeft2->run(BACKWARD);
    MotorRight2->run(FORWARD);
    
    delay(50);
    
    Serial.println("TRY TO REDIRECT RIGHT");
    
    MotorLeft1->run(FORWARD);  
    MotorRight1->run(FORWARD);  
    MotorLeft2->run(FORWARD);
    MotorRight2->run(FORWARD);
    
    counterlength = counterlength + 1;
    
    delay(200); 
    return;
  }*/
  
 else if (not done and turns == 1 and counterlength > 0 and (forwardright and last == 0 and ((irreadRight and not irreadFront and not irreadRear) or (irreadRight and irreadFront and not irreadRear)))) {
  MotorLeft1->run(BACKWARD);  
  MotorRight1->run(FORWARD);  
  MotorLeft2->run(BACKWARD);
  MotorRight2->run(FORWARD);
  
  delay(50);
  
  Serial.println("TRY TO REDIRECT LEFT");
  
  MotorLeft1->run(FORWARD);  
  MotorRight1->run(FORWARD);  
  MotorLeft2->run(FORWARD);
  MotorRight2->run(FORWARD);
  
  counterwidth = counterwidth + 1;
  
  delay(200);  
  }

  //same thing but for the left sensor
  /*if (not done and turns == 1 and counterlength > 0 and ((not irreadLeft and not irreadFront and not irreadRear) or (not irreadLeft and irreadFront and not irreadRear))) {
    MotorLeft1->run(FORWARD);  
    MotorRight1->run(FORWARD);  
    MotorLeft2->run(FORWARD);
    MotorRight2->run(FORWARD);
    
    forwardleft = 1;
    forwardright = 0;
    counterwidth = counterwidth + 1;
    
    Serial.println("2");
  }
  
  else if (not done and turns == 1 and counterlength > 0 and (forwardleft and last == 0 and ((a < 200 and not irreadFront and not irreadRear) or (a < 200 and irreadFront and not irreadRear)))) {
    MotorLeft1->run(BACKWARD);  
    MotorRight1->run(FORWARD);  
    MotorLeft2->run(BACKWARD);
    MotorRight2->run(FORWARD);
    
    delay(50);
    
    Serial.println("TRY TO REDIRECT LEFT");
    
    MotorLeft1->run(FORWARD);  
    MotorRight1->run(FORWARD);  
    MotorLeft2->run(FORWARD);
    MotorRight2->run(FORWARD);
    
    counterwidth = counterwidth + 1;
    
    delay(200);  
  }
  
  else if (not done and turns == 1 and counterlength > 0 and (forwardleft and last == 0 and ((b > 200 and not irreadFront and not irreadRear) or (b > 200 and irreadFront and not irreadRear)))) {
    MotorLeft1->run(FORWARD);  
    MotorRight1->run(BACKWARD);  
    MotorLeft2->run(FORWARD);
    MotorRight2->run(BACKWARD);
    
    delay(50);
    
    Serial.println("TRY TO REDIRECT LEFT");
    
    MotorLeft1->run(FORWARD);  
    MotorRight1->run(FORWARD);  
    MotorLeft2->run(FORWARD);
    MotorRight2->run(FORWARD);
    
    counterwidth = counterwidth + 1;
    
    delay(200);  
  }*/
  
  //next we start our turns tally.. turns now equal 0.. plus one after we make our first turn and head left across the top
  if (not done and turns == 0 and forwardright and irreadFront and irreadRear) {
    endtime = millis();
    accumtime = endtime - starttime;
    Serial.print(starttime);
    Serial.println("starttime");
    Serial.print(endtime);
    Serial.println("endtime");
    Serial.print(accumtime);
    Serial.println("accumtime");

    
    digitalWrite(pump, LOW);

    MotorLeft1->run(RELEASE);  
    MotorRight1->run(RELEASE);  
    MotorLeft2->run(RELEASE);
    MotorRight2->run(RELEASE);

    delay(1000);
    
    Serial.println("3");
      
    MotorLeft1->run(BACKWARD);  
    MotorRight1->run(BACKWARD);  
    MotorLeft2->run(BACKWARD);
    MotorRight2->run(BACKWARD);
    
    delay(2000); 

    MotorLeft1->run(RELEASE);  
    MotorRight1->run(RELEASE);  
    MotorLeft2->run(RELEASE);
    MotorRight2->run(RELEASE);
    
    if (squeegeeturnright == 0){
     myservo.attach(9);
     myservo.write(99);
     delay(2000);
     myservo.detach();
     squeegeeturnright = 1;
     squeegeeturnleft = 0;
  }
      MotorLeft1->setSpeed(50); //left rear speed set
      MotorRight1->setSpeed(200); //right speed set
      MotorLeft2->setSpeed(50); //left front speed set
      MotorRight2->setSpeed(200); //right speed set

        MotorLeft1->run(FORWARD);  
        MotorRight1->run(FORWARD);  
        MotorLeft2->run(FORWARD);
        MotorRight2->run(FORWARD);

        delay(5100);

      MotorLeft1->setSpeed(160); //left rear speed set
      MotorRight1->setSpeed(140); //right speed set
      MotorLeft2->setSpeed(160); //left front speed set
      MotorRight2->setSpeed(140); //right speed set
    
    //leftturn();
    
    // TEST stop to allow the sensors to regain position to make the next step
    MotorLeft1->run(RELEASE);  
    MotorRight1->run(RELEASE);  
    MotorLeft2->run(RELEASE);
    MotorRight2->run(RELEASE);
    
    delay(500);
    
    turns = 1;
    
    Serial.println("4");
    
    return; 
  }
  
  /*//same thing with left sensor
  if (not done and turns == 0 and forwardleft and irreadFront and irreadRear) {
    endtime = millis();
    accumtime = endtime - starttime;
    
    MotorLeft1->run(RELEASE);  
    MotorRight1->run(RELEASE);  
    MotorLeft2->run(RELEASE);
    MotorRight2->run(RELEASE);
    
    Serial.println("5");
    
    MotorLeft1->run(BACKWARD);  
    MotorRight1->run(BACKWARD);  
    MotorLeft2->run(BACKWARD);
    MotorRight2->run(BACKWARD);
    
    delay(900);
    
    MotorLeft1->run(FORWARD);  
    MotorRight1->run(BACKWARD);  
    MotorLeft2->run(FORWARD);
    MotorRight2->run(BACKWARD);
    
    delay(2900);
    
    // TEST stop to allow the sensors to regain position to make the next step
    MotorLeft1->run(RELEASE);  
    MotorRight1->run(RELEASE);  
    MotorLeft2->run(RELEASE);
    MotorRight2->run(RELEASE);
    
    delay(500);
    
    turns = 1;
    
    Serial.println("6");
    
    return; 
  }*/
  
  //once we see the left top edge we need to turn to go down.. now we need to go down for a little while.. then we need to turn back to go right across
  if (not done and turns == 1 and irreadFront and irreadRear){
    Serial.print(counterlength);
    Serial.println("count");
    distance = (counterlength * 33.87);

    digitalWrite(pump, LOW);
    
    MotorLeft1->run(RELEASE);  
    MotorRight1->run(RELEASE);  
    MotorLeft2->run(RELEASE);
    MotorRight2->run(RELEASE);
    
    Serial.println("7"); 
    
    MotorLeft1->run(BACKWARD);  
    MotorRight1->run(BACKWARD);  
    MotorLeft2->run(BACKWARD);
    MotorRight2->run(BACKWARD);
    
    delay(1500);

    MotorLeft1->run(RELEASE);  
    MotorRight1->run(RELEASE);  
    MotorLeft2->run(RELEASE);
    MotorRight2->run(RELEASE);

    if (squeegeeturnright == 1 and squeegeeturnleft == 0) {
     myservo.attach(9);
     myservo.write(87);
     delay(2000);
     myservo.detach();
     squeegeeturnright = 0;
     squeegeeturnleft = 1;
  }

      MotorLeft1->setSpeed(105); //left rear speed set
      MotorRight1->setSpeed(100); //right speed set
      MotorLeft2->setSpeed(105); //left front speed set
      MotorRight2->setSpeed(100); //right speed set

        MotorLeft1->run(BACKWARD);  
        MotorRight1->run(FORWARD);  
        MotorLeft2->run(BACKWARD);
        MotorRight2->run(FORWARD);

        delay(4500);

      MotorLeft1->setSpeed(152); //left rear speed set
      MotorRight1->setSpeed(157); //right speed set
      MotorLeft2->setSpeed(152); //left front speed set
      MotorRight2->setSpeed(157); //right speed set

        //leftturn();
    
    MotorLeft1->run(FORWARD);  
    MotorRight1->run(FORWARD);  
    MotorLeft2->run(FORWARD);
    MotorRight2->run(FORWARD);
    
    delay(1250);
    
    accumdistance = 4000;

      MotorLeft1->setSpeed(105); //left rear speed set
      MotorRight1->setSpeed(100); //right speed set
      MotorLeft2->setSpeed(105); //left front speed set
      MotorRight2->setSpeed(100); //right speed set
    
        MotorLeft1->run(BACKWARD);  
        MotorRight1->run(FORWARD);  
        MotorLeft2->run(BACKWARD);
        MotorRight2->run(FORWARD);

        delay(3500);

      MotorLeft1->setSpeed(150); //left rear speed set
      MotorRight1->setSpeed(163); //right speed set
      MotorLeft2->setSpeed(150); //left front speed set
      MotorRight2->setSpeed(163); //right speed set

        //leftturn();
    
    MotorLeft1->run(RELEASE);  
    MotorRight1->run(RELEASE);  
    MotorLeft2->run(RELEASE);
    MotorRight2->run(RELEASE);
    
    delay(500);
    
    last = left;
    turns = 2;
    
    Serial.println("8");
    return;
  } 


  /*if (not done and turns == 1 and (c < 200 or d > 200) and irreadFront and irreadRear){
    MotorLeft1->run(RELEASE);  
    MotorRight1->run(RELEASE);  
    MotorLeft2->run(RELEASE);
    MotorRight2->run(RELEASE);
    
    Serial.println("7"); 
    
    MotorLeft1->run(BACKWARD);  
    MotorRight1->run(FORWARD);  
    MotorLeft2->run(BACKWARD);
    MotorRight2->run(FORWARD);
    
    delay(100);
    
    MotorLeft1->run(BACKWARD);  
    MotorRight1->run(BACKWARD);  
    MotorLeft2->run(BACKWARD);
    MotorRight2->run(BACKWARD);
    
    delay(300);
    
    MotorLeft1->run(FORWARD);  
    MotorRight1->run(BACKWARD);  
    MotorLeft2->run(FORWARD);
    MotorRight2->run(BACKWARD);
    
    delay(50);
  }*/
  
 /* //same thing just left
  //once we see the left top edge we need to turn to go down.. now we need to go down for a little while.. then we need to turn back to go right across
  if (not done and turns == 1 and a > 200 and b < 200 and irreadFront and irreadRear){
    distance = (counterlength * 33.87);
    
    MotorLeft1->run(RELEASE);  
    MotorRight1->run(RELEASE);  
    MotorLeft2->run(RELEASE);
    MotorRight2->run(RELEASE);
    
    Serial.println("9"); 
    
    MotorLeft1->run(BACKWARD);  
    MotorRight1->run(BACKWARD);  
    MotorLeft2->run(BACKWARD);
    MotorRight2->run(BACKWARD);
    
    delay(900);
    
    MotorLeft1->run(FORWARD);  
    MotorRight1->run(BACKWARD);  
    MotorLeft2->run(FORWARD);
    MotorRight2->run(BACKWARD);
    
    delay(2700);
    
    MotorLeft1->run(FORWARD);  
    MotorRight1->run(FORWARD);  
    MotorLeft2->run(FORWARD);
    MotorRight2->run(FORWARD);
    
    delay(2500);
    
    accumdistance = 2500;
    
    MotorLeft1->run(FORWARD);  
    MotorRight1->run(BACKWARD);  
    MotorLeft2->run(FORWARD);
    MotorRight2->run(BACKWARD);
    
    delay(2700);
    
    MotorLeft1->run(RELEASE);  
    MotorRight1->run(RELEASE);  
    MotorLeft2->run(RELEASE);
    MotorRight2->run(RELEASE);
    
    delay(500);
    
    last = right;
    turns = 2;
    
    Serial.println("10");
  } */
  
  //move forward across the board
  if (turns == 2 and not done and last == left and not irreadFront and not irreadRear) {
    MotorLeft1->run(FORWARD);  
    MotorRight1->run(FORWARD);  
    MotorLeft2->run(FORWARD);
    MotorRight2->run(FORWARD);

    digitalWrite(pump, HIGH);
    
    Serial.println("11");
  }
   
  //now lets turn again and go the other direction
  if (not done and last == left and irreadFront and irreadRear){
    MotorLeft1->run(RELEASE);  
    MotorRight1->run(RELEASE);  
    MotorLeft2->run(RELEASE);
    MotorRight2->run(RELEASE); 
    
    Serial.println("12");
    
    MotorLeft1->run(BACKWARD);  
    MotorRight1->run(BACKWARD);  
    MotorLeft2->run(BACKWARD);
    MotorRight2->run(BACKWARD);
    
    delay(1500);

    MotorLeft1->run(RELEASE);  
    MotorRight1->run(RELEASE);  
    MotorLeft2->run(RELEASE);
    MotorRight2->run(RELEASE); 

    if (squeegeeturnright == 0){
     myservo.attach(9);
     myservo.write(99);
     delay(2000);
     myservo.detach();
     squeegeeturnright = 1;
     squeegeeturnleft = 0;
  }

      MotorLeft1->setSpeed(105); //left rear speed set
      MotorRight1->setSpeed(100); //right speed set
      MotorLeft2->setSpeed(105); //left front speed set
      MotorRight2->setSpeed(100); //right speed set
    
        MotorLeft1->run(FORWARD);  
        MotorRight1->run(BACKWARD);  
        MotorLeft2->run(FORWARD);
        MotorRight2->run(BACKWARD);

        delay(4500);

      MotorLeft1->setSpeed(152); //left rear speed set
      MotorRight1->setSpeed(157); //right speed set
      MotorLeft2->setSpeed(152); //left front speed set
      MotorRight2->setSpeed(157); //right speed set
    
    MotorLeft1->run(FORWARD);  
    MotorRight1->run(FORWARD);  
    MotorLeft2->run(FORWARD);
    MotorRight2->run(FORWARD);
    
    delay(900);
    
    accumdistance = accumdistance + 2000;

      MotorLeft1->setSpeed(105); //left rear speed set
      MotorRight1->setSpeed(100); //right speed set
      MotorLeft2->setSpeed(105); //left front speed set
      MotorRight2->setSpeed(100); //right speed set
    
        MotorLeft1->run(FORWARD);  
        MotorRight1->run(BACKWARD);  
        MotorLeft2->run(FORWARD);
        MotorRight2->run(BACKWARD);

        delay(3400);
    
    MotorLeft1->run(RELEASE);  
    MotorRight1->run(RELEASE);  
    MotorLeft2->run(RELEASE);
    MotorRight2->run(RELEASE);

      MotorLeft1->setSpeed(150); //left rear speed set
      MotorRight1->setSpeed(150); //right speed set
      MotorLeft2->setSpeed(150); //left front speed set
      MotorRight2->setSpeed(150); //right speed set
    
    last = right;
    turns = 2;
    
    Serial.println("13"); 
    
    return;
  }

  if(not done and last == right and turns == 2 and irreadLeft){
    MotorLeft1->run(FORWARD);  
    MotorRight1->run(BACKWARD);  
    MotorLeft2->run(FORWARD);
    MotorRight2->run(BACKWARD);
    
    delay(50);
    
    Serial.println("TRY TO REDIRECT RIGHT");
    
    MotorLeft1->run(FORWARD);  
    MotorRight1->run(FORWARD);  
    MotorLeft2->run(FORWARD);
    MotorRight2->run(FORWARD);
    
    delay(200);
      }
  
  if (not done and last == right and not irreadFront and not irreadRear) {
    MotorLeft1->run(FORWARD);  
    MotorRight1->run(FORWARD);  
    MotorLeft2->run(FORWARD);
    MotorRight2->run(FORWARD);
    
    Serial.println("14");
  } 
  
  /*if (not done and last == right and a < 200 and b < 200 and c < 200 and d < 200 and irreadFront and irreadRear and ((accumdistance + 3000) < accumtime)){
    MotorLeft1->run(RELEASE);  
    MotorRight1->run(RELEASE);  
    MotorLeft2->run(RELEASE);
    MotorRight2->run(RELEASE);
    
    Serial.println("15"); 
    
    MotorLeft1->run(BACKWARD);  
    MotorRight1->run(BACKWARD);  
    MotorLeft2->run(BACKWARD);
    MotorRight2->run(BACKWARD);
    
    delay(700);
    
    MotorLeft1->run(BACKWARD);  
    MotorRight1->run(FORWARD);  
    MotorLeft2->run(BACKWARD);
    MotorRight2->run(FORWARD);
    
    delay(4000);
    
    MotorLeft1->run(FORWARD);  
    MotorRight1->run(FORWARD);  
    MotorLeft2->run(FORWARD);
    MotorRight2->run(FORWARD);
    
    delay(2500);
    
    accumdistance = accumdistance + 2500;
    
    MotorLeft1->run(BACKWARD);  
    MotorRight1->run(FORWARD);  
    MotorLeft2->run(BACKWARD);
    MotorRight2->run(FORWARD);
    
    delay(4000);
    
    MotorLeft1->run(RELEASE);  
    MotorRight1->run(RELEASE);  
    MotorLeft2->run(RELEASE);
    MotorRight2->run(RELEASE);
    
    delay(500);
    
    last = left; 
    turns = 2;
    
    Serial.println("16"); 
  } */
  
  if (not done and last == right and ((accumdistance + 4000) > accumtime) and irreadFront and irreadRear) {
    Serial.println(accumdistance);
    Serial.println(accumtime);
    MotorLeft1->run(RELEASE);  
    MotorRight1->run(RELEASE);  
    MotorLeft2->run(RELEASE);
    MotorRight2->run(RELEASE);
    
    done = 1; 
    digitalWrite(pump, LOW);
    
    Serial.println("17"); 
    
    return; 
  }
  
  /*if ((not done and not almost) and last == left and ((accumdistance + 2500) > accumtime) and irreadFront and irreadRear) {
    MotorLeft1->run(RELEASE);  
    MotorRight1->run(RELEASE);  
    MotorLeft2->run(RELEASE);
    MotorRight2->run(RELEASE);
    
    almost = 1; 
    
    Serial.println("18");
    
    return;
  } 

  if ((not done and almost) and last == left and ((accumdistance + 2500) > accumtime) and irreadFront and irreadRear) {
    MotorLeft1->run(RELEASE);  
    MotorRight1->run(RELEASE);  
    MotorLeft2->run(RELEASE);
    MotorRight2->run(RELEASE);
    
    almost = 0;
    done = 1; 
    
    Serial.println("19");
  } */
  
  /*if (done and forwardright and last == right and not turnaround) {
    MotorLeft1->run(BACKWARD);  
    MotorRight1->run(BACKWARD);  
    MotorLeft2->run(BACKWARD);
    MotorRight2->run(BACKWARD);
    
    delay(1000);
    
    MotorLeft1->run(BACKWARD);  
    MotorRight1->run(FORWARD);  
    MotorLeft2->run(BACKWARD);
    MotorRight2->run(FORWARD); 
    
    delay(5400);
    
    Serial.println("20"); 
    
    turnaround = 1;
  }
  
  if (done and forwardright and turnaround and not irreadFront and not irreadRear) {
    MotorLeft1->run(FORWARD);  
    MotorRight1->run(FORWARD);  
    MotorLeft2->run(FORWARD);
    MotorRight2->run(FORWARD);
  }*/
  
  /*if (done and forwardright and turnaround and irreadFront and irreadRear) {
    MotorLeft1->run(RELEASE);  
    MotorRight1->run(RELEASE);  
    MotorLeft2->run(RELEASE);
    MotorRight2->run(RELEASE); 
    
    Serial.println("21"); 
  }
  
  if (done and forwardleft and last == left and not turnaround) {
    MotorLeft1->run(BACKWARD);  
    MotorRight1->run(BACKWARD);  
    MotorLeft2->run(BACKWARD);
    MotorRight2->run(BACKWARD);
    
    delay(1000);
    
    MotorLeft1->run(FORWARD);  
    MotorRight1->run(BACKWARD);  
    MotorLeft2->run(FORWARD);
    MotorRight2->run(BACKWARD);
    
    delay(5400);

    Serial.println("22");
    
    turnaround = 1; 
  }
  
  if (done and forwardleft and turnaround and not irreadFront and not irreadRear) {
    MotorLeft1->run(FORWARD);  
    MotorRight1->run(FORWARD);  
    MotorLeft2->run(FORWARD);
    MotorRight2->run(FORWARD);
  }
  
  if (done and forwardleft and turnaround and irreadFront and irreadRear) {
    MotorLeft1->run(RELEASE);  
    MotorRight1->run(RELEASE);  
    MotorLeft2->run(RELEASE);
    MotorRight2->run(RELEASE); 
    
    Serial.println("20"); 
  }*/
}
if (greenledStatus == 0) {
    MotorLeft1->run(RELEASE);  
    MotorRight1->run(RELEASE);  
    MotorLeft2->run(RELEASE);
    MotorRight2->run(RELEASE);   
}
}


/*void leftturn(){
  /*
   * Read in compass
   */
   /* Get a new sensor event 
   
      sensors_event_t event; 
      mag.getEvent(&event);
      
      float Pi = 3.14159;
      
      // Calculate the angle of the vector y,x
      heading = (atan2(event.magnetic.y,event.magnetic.x) * 180) / Pi;
      //heading = heading - 10;

      // Normalize to 0-360
      if (heading < 0)
      {
        Serial.print("0");
        heading = 360 + heading;
      }
      Serial.print("Compass Heading: ");
      Serial.println(heading);
      oldheading = heading;
      newheading = heading;

      if (oldheading < 91){
        oldheading = oldheading + 360;
        newheading = oldheading + 360;
      }

      compassstart = millis();
      while (newheading > (oldheading - 90) or newheading == (oldheading - 90)){
      sensors_event_t event; 
      mag.getEvent(&event);
      
      float Pi = 3.14159;
      
      newheading = (atan2(event.magnetic.y,event.magnetic.x) * 180) / Pi;
      newheading = newheading - 22;
      
      //heading = abs(heading);
      // Normalize to 0-360
      if (newheading > 91){
        greaterthan90 = greaterthan90 + 1;
      }
      if ((greaterthan90 == 0 or lessthan90 > 0) and newheading < 91){
        lessthan90 = lessthan90 + 1;
        newheading = newheading + 360;
      }

      Serial.print("Old Compass Heading: ");
      Serial.println(oldheading);
      Serial.print("New Compass Heading: ");
      Serial.println(newheading);

      MotorLeft1->setSpeed(127); //left rear speed set
      MotorRight1->setSpeed(121); //right speed set
      MotorLeft2->setSpeed(127); //left front speed set
      MotorRight2->setSpeed(121); //right speed set
      
        MotorLeft1->run(BACKWARD);  
        MotorRight1->run(FORWARD);  
        MotorLeft2->run(BACKWARD);
        MotorRight2->run(FORWARD);
      }
      compassstop = millis();
      compassturntime = compassstop - compassstart;
      greaterthan90 = 0;
      lessthan90 = 0;
      MotorLeft1->setSpeed(147); //left rear speed set
      MotorRight1->setSpeed(141); //right speed set
      MotorLeft2->setSpeed(147); //left front speed set
      MotorRight2->setSpeed(141); //right speed set
}*/


/*void rightturn(){
  /*
   * Read in compass
   */
   /* Get a new sensor event 
   
      sensors_event_t event; 
      mag.getEvent(&event);
      
      float Pi = 3.14159;
      
      // Calculate the angle of the vector y,x
      heading = (atan2(event.magnetic.y,event.magnetic.x) * 180) / Pi;
      //heading = heading - 10;

      // Normalize to 0-360
      if (heading < 0)
      {
        Serial.print("0");
        heading = 360 + heading;
      }
      Serial.print("Compass Heading: ");
      Serial.println(heading);
      oldheading = heading;
      newheading = heading;

      if ((oldheading + 90) > 360){
        oldheading = (oldheading + 90) - 360;
      }

      compassstart = millis();
      while (newheading < (oldheading + 90) or newheading == (oldheading + 90)){
      sensors_event_t event; 
      mag.getEvent(&event);
      
      float Pi = 3.14159;
      
      newheading = (atan2(event.magnetic.y,event.magnetic.x) * 180) / Pi;
      newheading = newheading - 22;
      //newheading = newheading - 10;

      //heading = abs(heading);
      // Normalize to 0-360
      if (newheading < 270){
        greaterthan90 = greaterthan90 + 1;
      }
      if ((greaterthan90 == 0 or lessthan90 > 0) and newheading > 270){
        lessthan90 = lessthan90 + 1;
        newheading = newheading - 360;
      }

      Serial.print("Old Compass Heading: ");
      Serial.println(oldheading);
      Serial.print("New Compass Heading: ");
      Serial.println(newheading);
      
        MotorLeft1->run(FORWARD);  
        MotorRight1->run(BACKWARD);  
        MotorLeft2->run(FORWARD);
        MotorRight2->run(BACKWARD);
      }
      compassstop = millis();
      compassturntime = compassstop - compassstart;
      greaterthan90 = 0;
      lessthan90 = 0;
}*/

void sendHttpResponse(WiFiEspClient client)
{
  // HTTP headers always start with a response code (e.g. HTTP/1.1 200 OK)
  // and a content-type so the client knows what's coming, then a blank line:


  client.println("HTTP/1.1 200 OK");
  client.println("Content-type:text/html");
  client.println();
  
  /*client.print(
    "HTTP/1.1 200 OK\r\n"
    "Content-Type: text/html\r\n"
    "Connection: close\r\n"  // the connection will be closed after completion of the response
    "Refresh: 60\r\n"        // refresh the page automatically every 20 sec
    "\r\n");*/
  
  // the content of the HTTP response follows the header:
  client.println("<br>");
  client.print("Solution level is ");
  solutionpounds = scale.get_units();
  solutionpercent = (((solutionpounds - .2)/(2.8)) * 100);
  if (solutionpercent < 2){
    solutionpercent = 0;
  }
  if (solutionpercent > 100){
    solutionpercent = 100;
  }
  client.print(solutionpounds, 2);
  client.print(" lbs ");
  client.print(solutionpercent);
  client.print(" %  ");
  //client.print("<meter value = solutionpercent max = '100'></meter>");
  client.println("<br>");
  client.println("<br>");
  client.print("Voltage level is ");
  voltage = tempvoltage * 11.132;
  client.print(voltage);
  client.print(" V   ");
  if(voltage < 10){
    voltagepercent = 0;
  }
  if(voltage > 12.3){
    voltagepercent = 100;
  }
  if(voltage > 10 and voltage < 12.3){
    voltagepercent = ((((voltage) - 10) / 2.3) * 100); 
  }
  client.print(voltagepercent);
  client.print(" %  ");
  //client.print("<meter value = '50' min = '0' max = '100'></meter>");
  client.println("<br>");
  client.println("<br>");
  
  client.print("SPAC is ");
  if (greenledStatus == 1 and not done == 1){
   client.print("ON"); 
  }
  if (greenledStatus == 0 and not done == 1){
    client.print("OFF");
  }
  if (done == 1){
    client.print("DONE");
  }
  
  /*client.println("<br>");
  client.println("<br>");
  
  client.println("Click <a href=\"/GH\">here</a> turn SPAC on<br>");

  client.println("<br>");
  client.println("<br>");
  
  client.println("Click <a href=\"/GL\">here</a> turn SPAC off<br>");*/
  
  // The HTTP response ends with another blank line:
  client.println();

  sample_count = 0;
  sum = 0;
}

void printWifiStatus()
{
  // print the SSID of the network you're attached to
  Serial.print("SSID: ");
  Serial.println(WiFi.SSID());

  // print your WiFi shield's IP address
  IPAddress ip = WiFi.localIP();
  Serial.print("IP Address: ");
  Serial.println(ip);

  // print where to go in the browser
  Serial.println();
  Serial.print("To see this page in action, open a browser to http://");
  Serial.println(ip);
  Serial.println();
}
